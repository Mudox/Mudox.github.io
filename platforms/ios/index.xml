<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Ios on Mudox </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/platforms/ios/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Wed, 29 Oct 2014 21:43:56 CST</updated>
    
    <item>
      <title>SWIFT OJECT-ORIENTED FEATURE</title>
      <link>http://localhost:1313/note/swift_oo/</link>
      <pubDate>Wed, 29 Oct 2014 21:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/swift_oo/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Class Like Constructs In Swift&lt;/h1&gt;

&lt;p&gt;In Swift, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt; all can:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;have &lt;strong&gt;properties&lt;/strong&gt; to keep states.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;have &lt;strong&gt;methods&lt;/strong&gt; to perform actions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;define &lt;strong&gt;subscript&lt;/strong&gt; operators to let user access their properties through
subscript syntax.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;define &lt;strong&gt;initializers&lt;/strong&gt; to have a reasonable initial state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;be &lt;strong&gt;extended&lt;/strong&gt; to have additional behaviors beyond their default implementations.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;conform to &lt;strong&gt;protocols&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Only &lt;code&gt;class&lt;/code&gt; can:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;have &lt;strong&gt;inheritance&lt;/strong&gt; capability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;have &lt;strong&gt;deinitializer&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;be &lt;strong&gt;referenced&lt;/strong&gt; by mutiple variable or constants. the &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;enum&lt;/code&gt;
are both value types.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Properties&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;stored properties&lt;/h2&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;lazy properties&lt;/h3&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;computed properties&lt;/h2&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;shorthand setter syntax&lt;/h3&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;shorthand read-only getter syntax&lt;/h3&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Initializers&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>SWIFT FEATURES</title>
      <link>http://localhost:1313/note/swift_features/</link>
      <pubDate>Tue, 14 Oct 2014 21:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/swift_features/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Powerful &lt;code&gt;switch&lt;/code&gt; Statement&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;no implicitly fallthrough&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;match multiple conditions in one case statement.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;match against range.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;match against tuple.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;value binding.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;where&lt;/code&gt; clause can provide more conditions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;break&lt;/code&gt; &amp;amp; &lt;code&gt;continue&lt;/code&gt; can &lt;em&gt;jump&lt;/em&gt; further (to some label)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var aPoint = (x: 2, y: -1)
// labeled `swtich`
// NOTE: only loop statements and &#39;switch&#39; statement can labeled.
theSwitch: switch aPoint {
// against tuple
case (0, 0):
  println(&amp;quot;origin point&amp;quot;)

// against multiple conditions separated by comma
case (1, 1), (2, 2):
  println(&amp;quot;(1, 1) or (2, 2)&amp;quot;)

// &#39;_&#39; means &#39;any value is ok&#39;
case (_, 0):
  // the `break` here is just like the `pass` in python, acting as a
  // &#39;placeholder statement&#39;, nullifing this case branch.
  break

case (0, _):
  println(&amp;quot;on the Y-axis&amp;quot;)

// against range
case (-2...2, -2...2):
  println(&amp;quot;on or in the 2x2 box&amp;quot;)

// value binding
case (let x, -1):
  println(&amp;quot;on the horizontal line y = -1, with a x value: \(x)&amp;quot;)

// where clause
// NOTE: `let` can be replaced with `var` if you need to change the bound
// value afterwards.
case (0, var y) where y &amp;gt;= 0:
  y++    // mutable
  println(&amp;quot;on the 1st or 2nd quadrant&amp;quot;)

// value binding as a whole, which is an required exhaustive match
case let (x, y):
  theLoop: for i in 1..&amp;lt;100 {
    switch i {
      case let x where (x &amp;amp; 1) == 1 // a odd number
        break theSwitch     // jump further
      default
        continue theLoop    // jump further
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Closure &amp;ndash; Too Much Sugar!&lt;/h1&gt;

&lt;p&gt;The closure in Swift language adopts many syntactic sugar.&lt;/p&gt;

&lt;p&gt;The basic full syntax of a closure is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;{
  (parameters) -&amp;gt; retrunType in
  ... statements ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example that uses the array&amp;rsquo;s method &lt;code&gt;sorted&lt;/code&gt; to sort an array of word.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var words = [ &amp;quot;Dolor&amp;quot;, &amp;quot;eum&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;suscipit&amp;quot;, &amp;quot;necessitatibus&amp;quot;, &amp;quot;quod&amp;quot;, &amp;quot;hic&amp;quot;, &amp;quot;dignissimos&amp;quot; ]
 
let sortedWords = words.sorted({
  (lhs: String, rhs: String) -&amp;gt; Bool in
  return lhs &amp;lt; rhs
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Sugar #0 &amp;ndash; trailing closure&lt;/h2&gt;

&lt;p&gt;Often, closure parameter is placed last in parameter list. Swift thus provides
&lt;strong&gt;trailing closure&lt;/strong&gt;, which means your can write the inline closure just
outside the parameter list, following the closing &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Futhermore, if the closure is the only parameter, then the parenthesis can be
omitted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// trailing closure
let sortedWords = words.sorted/*()*/ {
  (lhs: String, rhs: String) -&amp;gt; Bool in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Sugar #1 &amp;ndash; return type inference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;return type&lt;/strong&gt; can be inferred by swift compiler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit return type
let sortedWords = words.sorted {
  (lhs: String, rhs: String) /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Sugar #2 &amp;ndash; parameter type inference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;parameter types&lt;/strong&gt; can be inferred by swift compile as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit parameter types
let sortedWords = words.sorted {
  (lhs/*: String*/, rhs/*: String*/) /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Sugar #3 &amp;ndash; parenthesis-less&lt;/h2&gt;

&lt;p&gt;since no type annotation is needed, the &lt;strong&gt;parenthesis&lt;/strong&gt; can be omitted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit parenthesis
let sortedWords = words.sorted {
  /*(*/lhs/*: String*/, rhs/*: String)*/ /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Sugar #4 &amp;ndash; return statemetn inference&lt;/h2&gt;

&lt;p&gt;If the closure has one statement, then the &lt;strong&gt;return&lt;/strong&gt; statement can also be
inferred.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit &#39;return&#39;
let sortedWords = words.sorted {
  /*(*/lhs/*: String*/, rhs/*: String)*/ /*-&amp;gt; Bool*/ in
  /*return*/ lhs &amp;lt; rhs
}

//then we got:
let sortedWords = words.sorted { lhs, rhs in lhs &amp;lt; rhs }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_7&#34;&gt;Sugar #5 &amp;ndash; shorthand parameter name&lt;/h2&gt;

&lt;p&gt;Swift provides &lt;strong&gt;shorthand parameter names&lt;/strong&gt;: $0 for the 1st parameter, $1 for
the 2nd parameter, and so on. And as an side effect, the whole &lt;code&gt;(parameters) -&amp;gt;
returType in&lt;/code&gt; statment can be completely omitted&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// use shorthand parameters, omit the whole &#39;in&#39; statement
let sortedWords = words.sorted {
  /*(lhs: String, rhs: String) -&amp;gt; Bool in*/
  /*return*/ $0 &amp;lt; $1
}

// then we got:
let sortedWords = words.sorted { $0 &amp;lt; $1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Sugar #6 &amp;ndash; operater as a closure&lt;/h2&gt;

&lt;p&gt;In swift, &lt;strong&gt;operator&lt;/strong&gt; is a function, which in turn is a special closure, so&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// comes operator!
let sortedWords = words.sorted(&amp;lt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;Fully-fledged Enumeration&lt;/h1&gt;

&lt;p&gt;In Swift, enumeration is fully-fledged type. You can asssociate different data
with each enumeration memeber, or define a raw type for enumeration.&lt;/p&gt;

&lt;h2 id=&#34;toc_10&#34;&gt;Flexible definition syntax&lt;/h2&gt;

&lt;p&gt;you can define more than one member a line.&lt;/p&gt;

&lt;h2 id=&#34;toc_11&#34;&gt;Type inference&lt;/h2&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Associated Value&lt;/h2&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Raw type&lt;/h2&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Struct like enumeration&lt;/h2&gt;

&lt;p&gt;enumeration in Swift can have properties &amp;amp; methods.&lt;/p&gt;

&lt;p&gt;enumeration, like struct in Swift, is value type (while class is reference
acounted type).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>COCOA CONCURRENCY</title>
      <link>http://localhost:1313/note/cocoa_concurrency/</link>
      <pubDate>Wed, 24 Sep 2014 22:18:21 CST</pubDate>
      
      <guid>http://localhost:1313/note/cocoa_concurrency/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Members Of Cocoa Concurrency&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Operation Queue&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstract base class &lt;code&gt;NSOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSInvocation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSBlockOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Queue&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Operation Queue Features&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;graph-based dependencies&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;completion block&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;execution status monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prioritizeing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;canceling&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COCOA THREADING</title>
      <link>http://localhost:1313/note/cocoa_threading/</link>
      <pubDate>Wed, 24 Sep 2014 21:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/cocoa_threading/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Run Loop&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;4 roles participate in the run loop game:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;NSRun Loop&lt;/code&gt; &amp;amp; &lt;code&gt;CFRunLoop&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFStringRef&lt;/code&gt; associated to each instance of run
loop object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Source&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopSource&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input source&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Port-based source&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selctor on other threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Custom source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timer&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopTimerRef&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Explictly defined timer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector on current thread with delay&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Observer&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;4 ways to kill a run loop iteration:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;no sources exists&lt;/p&gt;

&lt;p&gt;since some system routines may install certain input sources to the run
 loop implictly, we should not kill a run loop iteration by clearing &amp;lsquo;&lt;em&gt;all&lt;/em&gt;&amp;lsquo;
 sources we known.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timeout&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sourced handled in one-shot mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicitly stoped by &lt;code&gt;CRunloopStop&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;3 kinds of perform selector sources.&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;on thread&lt;/th&gt;
&lt;th&gt;invocation&lt;/th&gt;
&lt;th&gt;delay&lt;/th&gt;
&lt;th&gt;blocking call?&lt;/th&gt;
&lt;th&gt;mode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;current thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;always non-blocking&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;other thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;main thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Alternatives To Threaing&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Operation Objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grand Central Dispatch (GCD)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Idle-time notifications&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Separate processes&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Cocoa Support For Threading&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cocoa threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POSIX threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Mutiprocessing Services&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Inter-Thread Communication&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Direct messageing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Global variables, shared memory &amp;amp; objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run loop sources&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ports &amp;amp; sockets&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Message queues&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa distributed objects&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Synchronization Tools&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atomic operation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;atomic add&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic increment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic decrement&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compare-and-swap&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-set&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-clear&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory barriers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Volatile variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Locks&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mutex&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;POSIX API provides &lt;code&gt;pthread_lock_t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa provides &lt;code&gt;NSLock&lt;/code&gt; &amp;amp;  &lt;code&gt;@synchronized()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive lock&lt;/p&gt;

&lt;p&gt;which is provided as class &lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Read-write lock (&lt;em&gt;pthread only&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Distributed lock&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spin lock (&lt;em&gt;not implemented&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Double-checked lock&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions (aka &lt;em&gt;condition variable&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector routines&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>